# -*- coding: utf-8 -*-
"""CompEvolutivaProjeto5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A3Ed6-VlkL50UJKlUDBtc0PwjS85rVSJ
"""

!git clone https://github.com/LeonardoMonte/CompEvolutiva.git
!pip install -q SwarmPackagepy

"""# Functions"""

import numpy as np
import random
import pandas as pd
import glob
import cv2
from sklearn.decomposition import PCA
from sklearn import preprocessing
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.optimizers import SGD
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import confusion_matrix
import time
from scipy.stats import friedmanchisquare
import matplotlib.pyplot as plt
from keras.models import model_from_json
from sklearn.model_selection import KFold
from sklearn.utils import shuffle

def reshape3dto2d(arrayphotos):

    size = len(arrayphotos)
    for x in range (0 , size):
        arrayphotos[x] = np.reshape(arrayphotos[x], (arrayphotos[x].shape[0], (arrayphotos[x].shape[1]*arrayphotos[x].shape[2])))

    return arrayphotos

def loadfolderimgs(path):

    arrayphotos = []

    for img in glob.glob(path):
        n = cv2.imread(img)
        arrayphotos.append(n)

    return arrayphotos
  
def Turntogray(arrayphotos):

    size = len(arrayphotos)
    for x in range (0,size):
        arrayphotos[x] = cv2.cvtColor(arrayphotos[x], cv2.COLOR_BGR2GRAY)

    return arrayphotos
  
def resizephotos(arrayphotos, size1, size2):

    size = len(arrayphotos)
    for x in range (0,size):
        arrayphotos[x] = cv2.resize(arrayphotos[x], (size1,size2))

    return arrayphotos
  
def gethumoments(arrayphotos):

    for x in range(len(arrayphotos)):

        arrayphotos[x] = cv2.HuMoments(cv2.moments(arrayphotos[x]), True).flatten()

    return arrayphotos
  
def amostra_estrat(tam , df , classe):
    classes = df[classe].unique()
    qtde_por_classe = round(tam / len(classes))
    amostras_por_classe = []
    for c in classes:
        indices_c = df[classe] == c
        obs_c = df[indices_c]
        amostra_c = obs_c.sample(qtde_por_classe)
        amostras_por_classe.append(amostra_c)
    amostra_estratificada = pd.concat(amostras_por_classe)
    return amostra_estratificada
  
def binaryadaptive(arrayphotos,threshold,val1):

    for x in range(len(arrayphotos)):
        arrayphotos[x] = cv2.adaptiveThreshold(arrayphotos[x],threshold,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,val1,10)
        
    return arrayphotos

def invertbinaryphotos(arrayphotos):

    for x in range(len(arrayphotos)):
        arrayphotos[x] = cv2.bitwise_not(arrayphotos[x])

    return arrayphotos
  
def getHOGplusHU(arrayphotos):
    hog = cv2.HOGDescriptor()
    for x in range(len(arrayphotos)):
        aux = []


        h = hog.compute(arrayphotos[x]).flatten()

        for ho in h:
            aux.append(ho)

        hu = cv2.HuMoments(cv2.moments(arrayphotos[x]), True).flatten()

        for huu in hu:
            aux.append(huu)

        arrayphotos[x] = aux

    return arrayphotos
  
def PCAdataframe(pcanumber,dataframe):

    pca = PCA(n_components=pcanumber)
    dataframe = pca.fit_transform(dataframe)

    return dataframe
  
  
class LocalBinaryPatterns:
  
    def __init__(self, numPoints, radius):
      # store the number of points and radius
      self.numPoints = numPoints
      self.radius = radius

    def describe(self, image, eps=1e-7):
      # compute the Local Binary Pattern representation
      # of the image, and then use the LBP representation
      # to build the histogram of patterns
      lbp = feature.local_binary_pattern(image, self.numPoints,
        self.radius, method="uniform")
      (hist, _) = np.histogram(lbp.ravel(),
        bins=np.arange(0, self.numPoints + 3),
        range=(0, self.numPoints + 2))

      # normalize the histogram
      hist = hist.astype("float")
      hist /= (hist.sum() + eps)

      # return the histogram of Local Binary Patterns
      return hist
    
def getHOGplusLBP(arrayphotos):
    hog = cv2.HOGDescriptor()
    lbp = LocalBinaryPatterns(8,4)
    for x in range(len(arrayphotos)):
        aux = []
        
        h = hog.compute(arrayphotos[x]).flatten()
        for ho in h:
            aux.append(ho)
            
        pbl = lbp.describe(arrayphotos[x])        
        for a in pbl:
            aux.append(a)
        
        arrayphotos[x] = aux

    return arrayphotos    
    

def normalize(df1):
    x = df1.values.astype(float)
    min_max_scaler = preprocessing.MinMaxScaler()
    scaled = min_max_scaler.fit_transform(x)
    df_normalized = pd.DataFrame(scaled)
    return df_normalized
  
  
def creatpopuMSRA(sizepopu,sizecromo):
    
  limit = np.sqrt(6/float(sizecromo))
  chromossomos = [np.random.uniform(low = -limit,high = limit, size = sizecromo) for x in range(sizepopu)]
  return chromossomos
  
def creatpopu(sizepopu, sizecromo):

    chromossomos = []
    for x in range(sizepopu):
        aux = []
        for y in range(sizecromo):
            element = random.uniform(-1,1)
            aux.append(element)

        chromossomos.append(aux)

    return chromossomos
  
def creatpopuSTD(sizepopu, sizecromo):

    std = []
    for x in range(sizepopu):
        aux2 = []
        for y in range(sizecromo):
            element2 = random.uniform(-1,1)/6
            aux2.append(element2)          

        std.append(aux2)

    return np.array(std)


# MLP PART

model = Sequential()
model.add(Dense(6, input_dim = 50, activation="relu", name='dense1'))
model.add(Dense(1, activation="sigmoid", name='dense2'))    
model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])


######## FITNESS PART ######################

arrayfitnessGA = []
arrayfitnessDE = []
arrayfitnessEE = []
arrayfitnessEEC = []
arrayfitnessPE = []
arrayfitnessGADE = []
arrayfitnessPSO = []
arrayfitnessGSO = []
arrayfitnessGSA = []
arrayfitnessGWO = []
arrayfitnessGWOGSO = []
arrayfitnessGSAPSO = []

############################ FITNESS KFOLD ############################


def fitnessGA(chromossome, Xtrain,ytrain,Xval,yval):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)
  
  if len(arrayfitnessGA) == 0:
    model_json = model.to_json()
    with open("modelGA.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGA.h5")

  atual = retorno[1]

  if len(arrayfitnessGA) > 1:
    if atual > arrayfitnessGA[np.argmax(arrayfitnessGA)]:
      model_json = model.to_json()
      with open("modelGA.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGA.h5")

  arrayfitnessGA.append(atual)
  
  return atual


def fitnessDE(chromossome,Xtrain,ytrain,Xval,yval):
    
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1))) 
  
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessDE) == 0:
    model_json = model.to_json()
    with open("modelDE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelDE.h5")

  atual = retorno[1]

  if len(arrayfitnessDE) > 1:
    if atual > arrayfitnessDE[np.argmax(arrayfitnessDE)]:
      model_json = model.to_json()
      with open("modelDE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelDE.h5")

  arrayfitnessDE.append(atual)
    
  return atual

def fitnessEE(chromossome,Xtrain,ytrain,Xval,yval):
  
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))  

  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessEE) == 0:
    model_json = model.to_json()
    with open("modelEE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelEE.h5")

  atual = retorno[1]

  if len(arrayfitnessEE) > 1:
    if atual > arrayfitnessEE[np.argmax(arrayfitnessEE)]:
      model_json = model.to_json()
      with open("modelEE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelEE.h5")

  arrayfitnessEE.append(atual)
    
  return atual

def fitnessEEC(chromossome,Xtrain,ytrain,Xval,yval):
   
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessEEC) == 0:
    model_json = model.to_json()
    with open("modelEEC.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelEEC.h5")

  atual = retorno[1]

  if len(arrayfitnessEEC) > 1:
    if atual > arrayfitnessEEC[np.argmax(arrayfitnessEEC)]:
      model_json = model.to_json()
      with open("modelEEC.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelEEC.h5")

  arrayfitnessEEC.append(atual)

  return atual

def fitnessPE(chromossome,Xtrain,ytrain,Xval,yval):
  
  
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessPE) == 0:
    model_json = model.to_json()
    with open("modelPE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelPE.h5")

  atual = retorno[1]

  if len(arrayfitnessPE) > 1:
    if atual > arrayfitnessPE[np.argmax(arrayfitnessPE)]:
      model_json = model.to_json()
      with open("modelPE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelPE.h5")

  arrayfitnessPE.append(atual)
    
  return atual


def fitnessGADE(chromossome,Xtrain,ytrain,Xval,yval):
  
  
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  

  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessGADE) == 0:
    model_json = model.to_json()
    with open("modelGADE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGADE.h5")

  atual = retorno[1]

  if len(arrayfitnessGADE) > 1:
    if atual > arrayfitnessGADE[np.argmax(arrayfitnessGADE)]:
      model_json = model.to_json()
      with open("modelGADE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGADE.h5")

  arrayfitnessGADE.append(atual)
    
  return atual


def fitnessPSO(chromossome,Xtrain,ytrain,Xval,yval):
  
  
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessPSO) == 0:
    model_json = model.to_json()
    with open("modelPSO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelPSO.h5")

  atual = retorno[1]

  if len(arrayfitnessPSO) > 1:
    if atual > arrayfitnessPSO[np.argmax(arrayfitnessPSO)]:
      model_json = model.to_json()
      with open("modelPSO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelPSO.h5")

  arrayfitnessPSO.append(atual)

  return atual

def fitnessGSO(chromossome,Xtrain,ytrain,Xval,yval):
    
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessGSO) == 0:
    model_json = model.to_json()
    with open("modelGSO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGSO.h5")

  atual = retorno[1]

  if len(arrayfitnessGSO) > 1:
    if atual > arrayfitnessGSO[np.argmax(arrayfitnessGSO)]:
      model_json = model.to_json()
      with open("modelGSO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGSO.h5")

  arrayfitnessGSO.append(atual)
  
  return atual


def fitnessGSA(chromossome,Xtrain,ytrain,Xval,yval):
    
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessGSA) == 0:
    model_json = model.to_json()
    with open("modelGSA.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGSA.h5")

  atual = retorno[1]

  if len(arrayfitnessGSA) > 1:
    if atual > arrayfitnessGSA[np.argmax(arrayfitnessGSA)]:
      model_json = model.to_json()
      with open("modelGSA.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGSA.h5")

  arrayfitnessGSA.append(atual)
  
  return atual


def fitnessGWO(chromossome,Xtrain,ytrain,Xval,yval):
    
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessGWO) == 0:
    model_json = model.to_json()
    with open("modelGWO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGWO.h5")

  atual = retorno[1]

  if len(arrayfitnessGWO) > 1:
    if atual > arrayfitnessGWO[np.argmax(arrayfitnessGWO)]:
      model_json = model.to_json()
      with open("modelGWO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGWO.h5")

  arrayfitnessGWO.append(atual)
  
  return atual

def fitnessGWOGSO(chromossome,Xtrain,ytrain,Xval,yval):
    
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessGWOGSO) == 0:
    model_json = model.to_json()
    with open("modelGWOGSO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGWOGSO.h5")

  atual = retorno[1]

  if len(arrayfitnessGWOGSO) > 1:
    if atual > arrayfitnessGWOGSO[np.argmax(arrayfitnessGWOGSO)]:
      model_json = model.to_json()
      with open("modelGWOGSO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGWOGSO.h5")

  arrayfitnessGWOGSO.append(atual)
  
  return atual

def fitnessGSAPSO(chromossome,Xtrain,ytrain,Xval,yval):
    
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))
  model.fit(Xtrain, ytrain, epochs=20, batch_size=256, verbose = False)
  retorno = model.evaluate(Xval,yval, verbose = False)

  if len(arrayfitnessGSAPSO) == 0:
    model_json = model.to_json()
    with open("modelGSAPSO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGSAPSO.h5")

  atual = retorno[1]

  if len(arrayfitnessGSAPSO) > 1:
    if atual > arrayfitnessGSAPSO[np.argmax(arrayfitnessGSAPSO)]:
      model_json = model.to_json()
      with open("modelGSAPSO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGSAPSO.h5")

  arrayfitnessGSAPSO.append(atual)
  
  return atual


############# LOAD MODEL ###############################33


def loadmodelGA():
  
  json_file = open('modelGA.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGA.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelDE():
  
  json_file = open('modelDE.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelDE.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelEE():
  
  json_file = open('modelEE.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelEE.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelEEC():
  
  json_file = open('modelEEC.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelEEC.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelPE():
  
  json_file = open('modelPE.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelPE.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model


def loadmodelGADE():
  
  json_file = open('modelGADE.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGADE.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelPSO():
  
  json_file = open('modelPSO.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelPSO.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelGSO():
  
  json_file = open('modelGSO.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGSO.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelGSA():
  
  json_file = open('modelGSA.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGSA.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model


def loadmodelGWO():
  
  json_file = open('modelGWO.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGWO.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model


def loadmodelGWOGSO():
  
  json_file = open('modelGWOGSO.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGWOGSO.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

def loadmodelGSAPSO():
  
  json_file = open('modelGSAPSO.json', 'r')
  loaded_model_json = json_file.read()
  json_file.close()
  loaded_model = model_from_json(loaded_model_json)
  loaded_model.load_weights("modelGSAPSO.h5")
  loaded_model.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])
  
  return loaded_model

############ LOAD MODEL ########################33

def evaluateEND(chromossome):
  
    w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
    w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
    
    model2 = loadmodelGA()
    model2.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
    model2.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

    #hist = model2.fit(df_train_nolabels, df_train_labels, epochs=20, batch_size=256, verbose = False )
    retorno = model2.evaluate(df_test_nolabels,df_test_labels, verbose = False)
  
    return retorno[1]

"""# Pre processing"""

#START Pre processing Images
from sklearn.model_selection import train_test_split

positivas = loadfolderimgs('CompEvolutiva/testepositiva/*.jpg')
negativas = loadfolderimgs('CompEvolutiva/nova classe negativa/*.jpg')
positivas = Turntogray(positivas)
negativas = Turntogray(negativas)
positivas = binaryadaptive(positivas,255,27)
negativas = binaryadaptive(negativas,255,27)
positivas = invertbinaryphotos(positivas)
negativas = invertbinaryphotos(negativas)

positivas = resizephotos(positivas, 64, 128)
negativas = resizephotos(negativas, 64, 128)

#positivas = gethumoments(positivas)
#negativas = gethumoments(negativas)

positivas = getHOGplusHU(positivas)
negativas = getHOGplusHU(negativas)

df1 = pd.DataFrame(positivas)
df2 = pd.DataFrame(negativas)

df1['Class'] = 1
df2['Class'] = 0

frames = [df1,df2]

df_final = pd.concat(frames, ignore_index=True)

df_finalaux = df_final.copy()

del df_final['Class']

df_final = pd.DataFrame(PCAdataframe(50,df_final))

df_final = normalize(df_final)

df_final['Class'] = df_finalaux['Class']

df_final = amostra_estrat(1400, df_final, 'Class')

cols = list(df_final.columns)
cols.remove('Class')
df_images_noclass = df_final[cols]  # SEPARANDO EM DOIS DATAFRAMES UM COM A CLASSE E OUTRO SEM
df_images_class = df_final['Class']

imagesnoclass = np.array(df_images_noclass)
imagesclass = np.array(df_images_class)
#X_train, X_test, y_train, y_test = train_test_split(np.array(df_images_noclass), np.array(df_images_class), test_size=0.3)


#labelsize = 219

#trainparampos = df1[:800,]
#testparampos = df1[800:,]
#trainparamneg = df2[:800,]
#testparamneg  = df2[800:,]

#trainparampos = pd.DataFrame(trainparampos)
#testparampos = pd.DataFrame(testparampos)
#trainparamneg = pd.DataFrame(trainparamneg)
#testparamneg = pd.DataFrame(testparamneg)

#trainlabelspos = pd.DataFrame(np.ones(800))
#trainlabelsneg = pd.DataFrame(np.zeros(800))
#testlabelspos = pd.DataFrame(np.ones(labelsize))
#testlabelsneg = pd.DataFrame(np.zeros(labelsize))

#framestrain = [trainparampos,trainparamneg]
#framestrainlabels = [trainlabelspos,trainlabelsneg]
#framestest = [testparampos,testparamneg]
#framestestlabels = [testlabelspos,testlabelsneg]

#df_train_nolabels = pd.concat(framestrain, ignore_index=True)
#df_train_labels = pd.concat(framestrainlabels, ignore_index=True)
#df_test_nolabels = pd.concat(framestest, ignore_index=True)
#df_test_labels = pd.concat(framestestlabels, ignore_index=True)

#df_train_nolabels = pd.DataFrame(X_train2)
#df_train_labels = pd.DataFrame(y_train2)
#df_validation_nolabels = pd.DataFrame(X_test2)
#df_validation_labels = pd.DataFrame(y_test2)

#df_test_nolabels = pd.DataFrame(X_test)
#df_test_labels = pd.DataFrame(y_test)


#print(df_train_nolabels)
#print(df_train_labels)
#print(df_test_labels)
#print(df_test_nolabels)

#END preprocessing

"""# GA"""

def crossover(pai1, pai2):
  
  beta = random.random()
  
  filho = pai1+beta*(pai2-pai1)
  
  filho = np.clip(filho,-1,1)
  
  return filho

def mutation(filho):
  
  beta = random.random()
  
  filho = beta*filho
  filho = np.clip(filho,-1,1)
  
  return filho
                           
def newgentournement(score,population):
  
  newgen = []
  
  scorescopy = score.copy() 
  index1 = np.argmax(scorescopy)
  scorescopy[index1] = -999999
  index2 = np.argmax(scorescopy)
  
  newgen.append(population[index1])
  newgen.append(population[index2])
  
  for x in range(int((len(population)-2)/2)):
  
    index1 = random.randint(0,len(population)-1)
    index2 = random.randint(0,len(population)-1)
  
    index3 = random.randint(0,len(population)-1)
    index4 = random.randint(0,len(population)-1) 
    
    if score[index1] > score[index2]:
      pai1 = population[index1]
    else:
      pai1 = population[index2]
    
    if score[index3] > score[index4]:
      pai2 = population[index3]
    else:
      pai2 = population[index4]
  
  
    txcrs = random.uniform(0,1)
  
    if txcrs <= 0.7:
      son1 = crossover(np.array(pai1),np.array(pai2))
      son2 = crossover(np.array(pai2),np.array(pai1))
    else:
      son1 = pai1
      son2 = pai2
    
    txmt = random.uniform(0,1)
    
    if txmt <= 0.03:
      mutation(np.array(son1))
      mutation(np.array(son2))
    
    newgen.append(son1)
    newgen.append(son2)
   
  
  return np.array(newgen)



def GArun(population,ite,Xtrain,ytrain,Xval,yval):
  
  tempototalinicioGA = time.time()
  populationGA = population
  scoresGA = []
  scoresfinalGA = []
  chromofinaisGA = []

  for popu in populationGA:
    scoresGA.append(fitnessGA(popu,Xtrain,ytrain,Xval,yval))

  for x in range(ite):

    populationGA = newgentournement(scoresGA, populationGA)

    scoresGA = []
    for popu in populationGA:
      scoresGA.append(fitnessGA(popu,Xtrain,ytrain,Xval,yval))

    scoresfinalGA.append(scoresGA[np.argmax(scoresGA)])
    chromofinaisGA.append(populationGA[np.argmax(scoresGA)])

  tempototalfimGA = time.time()
  tempototalGA = tempototalfimGA - tempototalinicioGA
  
  return scoresfinalGA,chromofinaisGA,tempototalGA

"""# DE"""

def de(fobj, bounds, population,its,popsize,Xtrain,ytrain,Xval,yval, mut=0.8, crossp=0.7):
    
    timeinicio = time.time()
    dimensions = len(population[0])
    pop = population
    min_b, max_b = np.asarray(bounds).T
    diff = np.fabs(min_b - max_b)
    #pop_denorm = min_b + pop * diff
    fitness = np.asarray([fobj(ind,Xtrain,ytrain,Xval,yval) for ind in pop])
    best_idx = np.argmax(fitness)
    best = pop[best_idx]
    
    melhoresgen = []
    melhoresfit = []
    
    for i in range(its):
        for j in range(popsize):
            idxs = [idx for idx in range(popsize) if idx != j]
            a, b, c = pop[np.random.choice(idxs, 3, replace = False)] 
            mutant = np.clip(a + mut * (b - c), -1, 1)
            cross_points = np.random.rand(dimensions) < crossp

            if not np.any(cross_points):
                cross_points[np.random.randint(0, dimensions)] = True
            trial = np.where(cross_points, mutant, pop[j])
            #trial_denorm = min_b + trial * diff
            f = fobj(trial,Xtrain,ytrain,Xval,yval)
            if f > fitness[j]:
                fitness[j] = f
                pop[j] = trial
                if f > fitness[best_idx]:
                    best_idx = j
                    best = trial
        melhoresgen.append(best)
        melhoresfit.append(fitness[best_idx])
    timefim = time.time()   
    return melhoresgen,melhoresfit, timefim-timeinicio

"""# GA DE HYBRID"""

def defevoHYBRID(fobj, bounds, population, popsize,Xtrain,ytrain,Xval,yval, mut=0.8, crossp=0.7, its=1):
    
    timeinicio = time.time()
    dimensions = len(population[0])
    pop = population#np.random.rand(popsize, dimensions)
    min_b, max_b = np.asarray(bounds).T
    diff = np.fabs(min_b - max_b)
    #pop_denorm = min_b + pop * diff
    fitness = np.asarray([fobj(ind,Xtrain,ytrain,Xval,yval) for ind in pop])
    best_idx = np.argmax(fitness)
    best = pop[best_idx]
    
    for i in range(its):
        for j in range(popsize):
            idxs = [idx for idx in range(popsize) if idx != j]
            a, b, c = pop[np.random.choice(idxs, 3, replace = False)] 
            mutant = np.clip(a + mut * (b - c), -1, 1)
            cross_points = np.random.rand(dimensions) < crossp

            if not np.any(cross_points):
                cross_points[np.random.randint(0, dimensions)] = True
            trial = np.where(cross_points, mutant, pop[j])
            #trial_denorm = min_b + trial * diff
            f = fobj(trial,Xtrain,ytrain,Xval,yval)
            if f > fitness[j]:
                fitness[j] = f
                pop[j] = trial
                if f > fitness[best_idx]:
                    best_idx = j
                    best = trial
    timefim = time.time()   
    return best,fitness[best_idx], timefim-timeinicio


def GADErun(populationGADE,ite,Xtrain,ytrain,Xval,yval):
  
  tempototalinicioGADE = time.time()
  scoreshalfGA = []
  scoreshalfDE = []
  scoresfinalGADE = []
  chromofinaisGADE = []
  popusplited = np.split(np.array(populationGADE),2)
  halfpopulationGA = popusplited[0]
  halfpopulationDE = popusplited[1]

  timeinicialGADE = time.time()
  
  for popu in halfpopulationGA:
    scoreshalfGA.append(fitnessGADE(popu,Xtrain,ytrain,Xval,yval))

  for x in range(ite):  

    halfpopulationGA = newgentournement(scoreshalfGA, halfpopulationGA)

    scoreshalfGA = []
    for popu in halfpopulationGA:
      scoreshalfGA.append(fitnessGADE(popu,Xtrain,ytrain,Xval,yval))

    atualbestGA = halfpopulationGA[np.argmax(scoreshalfGA)]

    halfpopulationDE[random.randint(0,len(halfpopulationDE)-1)] = atualbestGA

    bestchromo, fitnessbest,timeGADE = defevoHYBRID(fitnessGADE , (-1,1) , np.array(halfpopulationDE),len(halfpopulationDE),Xtrain,ytrain,Xval,yval)

    scoresfinalGADE.append(fitnessbest)
    chromofinaisGADE.append(bestchromo)

    halfpopulationGA[random.randint(0,len(halfpopulationGA)-1)] = bestchromo

  timefinalGADE = time.time()
  timetotalGADE = timefinalGADE - timeinicialGADE 
  
  return scoresfinalGADE,chromofinaisGADE,timetotalGADE

"""# EE"""

def creatpopuEE(sizepopu, sizecromo):

    chromossomos = []
    std = []
    for x in range(sizepopu):
        aux = []
        aux2 = []
        for y in range(sizecromo):
            element = random.uniform(-1,1)
            element2 = random.uniform(-1,1)
            aux.append(element)
            aux2.append(element2)          

        chromossomos.append(aux)
        std.append(aux2)

    return np.array(chromossomos), np.array(std)

  
def crossoverEE(pai1,pai2,std1,std2):
  
  son = []
  stdson = []
  
  for x in range(len(pai1)):
    
    randomvalue = random.random()
    
    if randomvalue > 0.5:
      son.append(pai1[x])
      stdson.append(std1[x])
    else:
      son.append(pai2[x])
      stdson.append(std2[x])
  
  return np.array(son), np.array(stdson)

def newgentournementEE(score,population,std,lambd):
  
  newgen = []
  newgenstd = []
  
  for x in range(lambd):
  
    index1 = random.randint(0,len(population)-1)
    index2 = random.randint(0,len(population)-1)
  
    index3 = random.randint(0,len(population)-1)
    index4 = random.randint(0,len(population)-1) 
    
    if score[index1] > score[index2]:
      pai1 = population[index1]
      std1 = std[index1]
    else:
      pai1 = population[index2]
      std1 = std[index2]
    
    if score[index3] > score[index4]:
      
      pai2 = population[index3]
      std2 = std[index3]
      
    else:
      
      pai2 = population[index4]
      std2 = std[index4]
     
  
    son, stdson = crossoverEE(np.array(pai1),np.array(pai2),np.array(std1),np.array(std2))
    
    newgen.append(son)
    newgenstd.append(stdson)
   
  
  
  return np.array(newgen),np.array(newgenstd)


def bestindEE(score,sizepopu):
  
  scorecopy = score.copy()
  ind = []
  for x in range(sizepopu):
    index = np.argmax(scorecopy)
    ind.append(index)
    scorecopy[index] = -99999
  
  return ind


def mutationEE(newgen,newgenstd):
  
  rand1 = random.gauss(0,1)
  mutnewgenstd = newgenstd*np.exp(rand1)
  mutnewgenstd = np.clip(mutnewgenstd, -1,1)
  
  mutnewgen = []
  
  for x,y in zip(newgen, mutnewgenstd):
    randvalue = random.gauss(0,y)
    mutnewgen.append(x+randvalue)
  
  mutnewgen = np.clip(mutnewgen,-1,1)
  
  return np.array(mutnewgen),np.array(mutnewgenstd)


def EErun(populationEE,stdsEE,ite,Xtrain,ytrain,Xval,yval):
  
  tempoinicialEE = time.time()
  sizeEE = len(populationEE)
  scoresEE = []
  scoresfinalEE = []
  chromofinaisEE = []

  for popu in populationEE:
    scoresEE.append(fitnessEE(popu,Xtrain,ytrain,Xval,yval))

  for x in range(ite):

    miEE, mistdEE = newgentournementEE(scoresEE,populationEE,stdsEE,len(populationEE)*2)
    miEE, mistdEE = mutationEE(miEE,mistdEE)

    scoresEE = []
    for popu in miEE:
      scoresEE.append(fitnessEE(popu,Xtrain,ytrain,Xval,yval))

    scoresfinalEE.append(scoresEE[np.argmax(scoresEE)])

    bestsEE = bestindEE(scoresEE,sizeEE)
    populationEE = miEE[bestsEE]
    stdsEE = mistdEE[bestsEE]
    scoresEE = np.array(scoresEE)
    bestscoresEE = scoresEE[bestsEE]
    chromofinaisEE.append(populationEE[np.argmax(bestscoresEE)])

  tempofinalEE = time.time()
  tempototalEE = tempofinalEE - tempoinicialEE
  
  return scoresfinalEE,chromofinaisEE,tempototalEE

"""# EE Cauchy"""

import math
 
def crossoverEEC(pai1,pai2,std1,std2):
  
  son = []
  stdson = []
  
  for x in range(len(pai1)):
    
    randomvalue = random.random()
    
    if randomvalue > 0.5:
      son.append(pai1[x])
      stdson.append(std1[x])
    else:
      son.append(pai2[x])
      stdson.append(std2[x])
  
  return np.array(son), np.array(stdson)

def newgentournementEEC(score,population,std,lambd):
  
  newgen = []
  newgenstd = []
  
  for x in range(lambd):
  
    index1 = random.randint(0,len(population)-1)
    index2 = random.randint(0,len(population)-1)
  
    index3 = random.randint(0,len(population)-1)
    index4 = random.randint(0,len(population)-1) 
    
    if score[index1] > score[index2]:
      pai1 = population[index1]
      std1 = std[index1]
    else:
      pai1 = population[index2]
      std1 = std[index2]
    
    if score[index3] > score[index4]:
      
      pai2 = population[index3]
      std2 = std[index3]
      
    else:
      
      pai2 = population[index4]
      std2 = std[index4]
     
  
    son, stdson = crossoverEE(np.array(pai1),np.array(pai2),np.array(std1),np.array(std2))
    
    newgen.append(son)
    newgenstd.append(stdson)
   
  
  
  return np.array(newgen),np.array(newgenstd)


def bestindEEC(score,sizepopu):
  
  scorecopy = score.copy()
  ind = []
  for x in range(sizepopu):
    index = np.argmax(scorecopy)
    ind.append(index)
    scorecopy[index] = -99999
  
  return ind


def mutationEEC(newgen,newgenstd):
  
  rand1 = random.gauss(0,1)
  mutnewgenstd = newgenstd*np.exp(rand1)
  mutnewgenstd = np.clip(mutnewgenstd, -1,1)
  
  mutnewgen = []
  
  for x,y in zip(newgen, mutnewgenstd):
    cauchy = np.random.standard_cauchy(len(newgen[0]))         
    mutnewgen.append(x+np.multiply(y,cauchy))
  
  mutnewgen = np.clip(mutnewgen,-1,1)
  
  return np.array(mutnewgen),np.array(mutnewgenstd)


def EECrun(populationEEC,stdsEEC,ite,Xtrain,ytrain,Xval,yval):
  
  tempoinicialEEC = time.time()
  sizeEEC = len(populationEEC)
  scoresEEC = []
  scoresfinalEEC = []
  chromofinaisEEC = []

  for popu in populationEEC:
    scoresEEC.append(fitnessEEC(popu,Xtrain,ytrain,Xval,yval))

  for x in range(ite):

    miEEC, mistdEEC = newgentournementEEC(scoresEEC,populationEEC,stdsEEC,len(populationEEC)*2)
    miEEC, mistdEEC = mutationEEC(miEEC,mistdEEC)

    scoresEEC = []
    for popu in miEEC:
      scoresEEC.append(fitnessEEC(popu,Xtrain,ytrain,Xval,yval))

    scoresfinalEEC.append(scoresEEC[np.argmax(scoresEEC)])

    bestsEEC = bestindEE(scoresEEC,sizeEEC)
    populationEEC = miEEC[bestsEEC]
    stdsEEC = mistdEEC[bestsEEC]
    scoresEEC = np.array(scoresEEC)
    bestscoresEEC = scoresEEC[bestsEEC]
    chromofinaisEEC.append(populationEEC[np.argmax(bestscoresEEC)])

  tempofinalEEC = time.time()
  tempototalEEC = tempofinalEEC - tempoinicialEEC
  
  return scoresfinalEEC,chromofinaisEEC,tempototalEEC

"""#PE"""

def creatpopuPE(sizepopu, sizecromo):

    std = []
    for x in range(sizepopu):
        aux = []
        aux2 = []
        for y in range(sizecromo):
            element = random.uniform(-1,1)
            element2 = random.uniform(-1,1)/6
            aux.append(element)
            aux2.append(element2)          

        chromossomos.append(aux)
        std.append(aux2)

    return np.array(chromossomos), np.array(std)
  
  

def mutationPE(daddys,dadstd,dimension):
  
  
  newgen = []
  newgenstd = []
  tline = (np.sqrt(2*np.sqrt(dimension)))**-1
  t = (np.sqrt(2*dimension))**-1
  
  for x in range(len(daddys)):
    rand1 = random.gauss(0,1)
    newgen.append(daddys[x]+dadstd[x]*rand1)
  
  for dad2 in dadstd:
    rand2 = random.gauss(0,1)
    aux = []
    for y in range(len(dad2)):
      rand3 = random.gauss(0,1)
      aux.append(dad2[y]*np.exp(tline*rand2+t*rand3))
    newgenstd.append(aux)
  
  newgen = np.clip(newgen,-1,1)
  newgenstd = np.clip(newgenstd,-1,1)
  return np.array(newgen),np.array(newgenstd)
  

def bestindPE(score,sizepopu):
  
  scorecopy = score.copy()
  ind = []
  for x in range(sizepopu):
    index = np.argmax(scorecopy)
    ind.append(index)
    scorecopy[index] = -99999
  
  return ind

  
def tournamentPE(newgen,newgenstd,oldgen, oldgenstd, scores,qvalue,Xtrain,ytrain,Xval,yval):
  
  dad = np.concatenate((oldgen,newgen))
  dadstd = np.concatenate((oldgenstd,newgenstd))
  
  scnewgen = []
  for popu in newgen:
    scnewgen.append(fitnessPE(popu,Xtrain,ytrain,Xval,yval))
  newscores = np.concatenate((scores,scnewgen))
  
  qselectds = []
  for x in range(qvalue):
    ha = random.randint(0,(len(dad)-1))
    qselectds.append(ha)
    
  result = np.zeros(len(dad))
  
  for ai in range(len(dad)):
    for sel in qselectds:
      if newscores[ai] > newscores[sel]:
        result[ai] +=1
      
  
  indices = bestindPE(result,len(oldgen))
  finalgen = dad[indices]
  finalgenstd = dadstd[indices]
  finalscores = newscores[indices]
  
  return np.array(finalgen), np.array(finalgenstd), np.array(finalscores)
  

def PErun(populationPE,stdsPE,ite,Xtrain,ytrain,Xval,yval):
  
  timeinicialPE = time.time()
  scoresfinalPE = []
  chromofinaisPE = []
  scoresPE = []
  
  for popu in populationPE:
    scoresPE.append(fitnessPE(popu,Xtrain,ytrain,Xval,yval))

  for x in range(ite):
    newgenPE, newgen2PE = mutationPE(populationPE,stdsPE,len(populationPE[0]))
    populationPE, stdsPE , scoresPE = tournamentPE(newgenPE,newgen2PE,populationPE,stdsPE,scoresPE,len(populationPE)+int(len(populationPE)/2),Xtrain,ytrain,Xval,yval) 
    scoresfinalPE.append(scoresPE[np.argmax(scoresPE)])
    chromofinaisPE.append(populationPE[np.argmax(scoresPE)])


  timefinalPE = time.time()
  timetotalPE = timefinalPE - timeinicialPE
  
  return scoresfinalPE,chromofinaisPE,timetotalPE

"""# PSO"""

def PSOrun(population,fitness,lb,ub,iteration,Xtrain,ytrain,Xval,yval,w=0.5,c1=1,c2=1):
  
  scores = []
  n = np.array(population).shape[0]
  dimension = np.array(population).shape[1]
  
  velocity = np.zeros((n,dimension))
  
  Pbest = population[np.array([fitness(x,Xtrain,ytrain,Xval,yval)
                              for x in population]).argmax()]
  Gbest = Pbest
  
  for t in range(iteration):
    
    r1 = np.random.random((n,dimension))
    r2 = np.random.random((n, dimension))
    velocity = w * velocity + c1 * r1 * (
        Pbest - population) + c2 * r2 * (
        Gbest - population)
    population += velocity
    population = np.clip(population, lb, ub)  
    
    Pbest = population[np.array([fitness(x,Xtrain,ytrain,Xval,yval)
                                for x in population]).argmax()]
    
    fitPbest = fitness(Pbest,Xtrain,ytrain,Xval,yval)
    scores.append(fitPbest)
    
    if fitPbest > fitness(Gbest,Xtrain,ytrain,Xval,yval):
      Gbest = Pbest
      
  
  return scores, Gbest

"""# GSO (Group search)"""

import numpy as np

def GSO(fitness, lb, ub, ite, population,Xtrain,ytrain,Xval,yval):

    popsize = np.array(population).shape[0]
    ndim = np.array(population).shape[1]

    initial_angles = np.pi / 4 * np.ones((popsize, (ndim - 1)))
    angle = initial_angles.copy()
    lowerbound = np.zeros((popsize, ndim))
    upperbound = np.zeros((popsize, ndim))

    for x in range(popsize):
        lowerbound[x, :] = lb
        upperbound[x, :] = ub

    vmax = np.ones((popsize, ndim))
    for x in range(ndim):
        vmax[:, x] = upperbound[:, x] - lowerbound[:, x]

    l_max = np.linalg.norm(vmax[1, :])

    distance = l_max * np.tile(np.ones((popsize, 1)), (ndim, 1))
    distance = distance.reshape((popsize), ndim)

    a = np.round((ndim + 1) ** 0.5)

    max_pursuit_angle = (np.pi / (a ** 2))
    max_turning_angle = max_pursuit_angle / 2

    direction = np.zeros((popsize, ndim))

    for x in range(popsize):
        direction[x, 0] = (np.cos(angle[x, 1]))
        for y in range(1, ndim - 1):
            direction[x, y] = np.cos(angle[x, y]) * np.prod(np.sin(angle[x, y:ndim - 1]))
        direction[x, ndim - 1] = np.prod(np.sin(angle[x, :ndim]))

    fvalue = np.zeros(popsize)

    for i in range(popsize):
        fvalue[i] = fitness(population[i],Xtrain,ytrain,Xval,yval)

    outflag = np.where((population <= lowerbound) | (population >= upperbound), 1, 0)
    population = population - outflag * distance * direction

    index = np.argmax(fvalue)
    fbestval = fvalue[index]
    bestmember = population[index]
    #print(fbestval)

    oldangle = angle.copy()
    oldindex = index.copy()
    badcounter = 0
    atribu = 0
    best = np.zeros(ite)

    for itera in range(ite):

        for j in range(popsize):
            R1 = np.random.randn(1)
            R2 = np.random.rand(1, ndim - 1)[0]
            R3 = np.random.rand(1, ndim)[0]

            if j == index:

                distance[j, :] = l_max * R1

                sampleposition = []
                sampleangle = []
                samplevalue = []
                sampledirection = []

                if badcounter >= a ** 2:
                    angle[j, :] = oldangle[j, :]

                sampleposition.append(population[j, :])
                sampleangle.append(angle[j, :])
                samplevalue.append(fvalue[j])
                sampledirection.append(direction[j, :])

                ### LOOK STRAIGHT
                direction[j, 0] = np.prod(np.cos(angle[j, :ndim - 1]))
                for i in range(i, ndim - 1):
                    direction[j, i] = np.sin(angle[j, i]) * np.prod(np.cos(angle[j, i:ndim - 1]))
                direction[j, ndim - 1] = np.sin(angle[j, ndim - 2])

                straightposition = population[j, :] + distance[j, :] * direction[j, :]
                outflag = np.where((straightposition > upperbound[j, :]) | (straightposition < lowerbound[j, :]), 1, 0)
                straightposition = straightposition - outflag * distance[j, :] * direction[j, :]
                straightfvalue = fitness(straightposition,Xtrain,ytrain,Xval,yval)
                sampleposition.append(straightposition)
                sampleangle.append(angle[j, :])
                samplevalue.append(straightfvalue)
                sampledirection.append(direction[j, :])
                ###### END LOOK STRAIGHT

                ###### LOOK LEFT
                leftangle = angle[j, :] + max_pursuit_angle * R2 / 2
                direction[j, 0] = np.prod(np.cos(leftangle[:ndim - 1]))
                for i in range(1, ndim - 1):
                    direction[j, i] = np.sin(leftangle[i]) * np.prod(np.cos(leftangle[i:ndim - 1]))
                direction[j, ndim - 1] = np.sin(leftangle[ndim - 2])

                leftposition = population[j, :] + distance[j, :] * direction[j, :]
                outflag = np.where((leftposition > upperbound[j, :]) | (leftposition < lowerbound[j, :]), 1, 0)
                leftposition = leftposition - outflag * distance[j, :] * direction[j, :]
                leftfvalue = fitness(leftposition,Xtrain,ytrain,Xval,yval)
                sampleposition.append(leftposition)
                sampleangle.append(leftangle[:])
                samplevalue.append(leftfvalue)
                sampledirection.append(direction[j, :])
                ####END LOOK LEFT

                ##### LOOK RIGHT
                rightangle = angle[j, :] - max_pursuit_angle * R2 / 2  # look right
                direction[j, 1] = np.prod(np.cos(rightangle[:ndim - 1]))
                for i in range(1, ndim - 1):
                    direction[j, i] = np.sin(rightangle[i]) * np.prod(np.cos(rightangle[i:ndim - 1]))
                direction[j, ndim - 1] = np.sin(rightangle[ndim - 2])


                rightposition = population[j, :] + distance[j, :] * direction[j, :]
                outflag = np.where((rightposition > upperbound[j, :]) | (rightposition < lowerbound[j, :]), 1, 0)
                rightposition = rightposition - outflag * distance[j, :] * direction[j, :]
                rightfvalue = fitness(rightposition,Xtrain,ytrain,Xval,yval)
                sampleposition.append(rightposition)
                sampleangle.append(rightangle[:])
                samplevalue.append(rightfvalue)
                sampledirection.append(direction[j, :])
                #### END LOOK RIGHT

                best_position_id = np.argmax(samplevalue)
                fbestdirectionval = samplevalue[best_position_id]
                
                population[j, :] = sampleposition[best_position_id][:]

                if best_position_id != 1:
                    angle[j, :] = sampleangle[best_position_id][:]
                    oldangle[j, :] = angle[j, :].copy()
                    badcounter = 0
                else:
                    badcounter += 1
                    angle[j, :] = angle[j, :] + max_turning_angle * R2

            else:
                #print(j)
                angle[j,:ndim - 1] = angle[j, :ndim - 1] + max_turning_angle * R2

                if np.random.rand() > 0.2:

                    distance[j, :] = R3 * (bestmember - population[j, :])
                    population[j, :] = population[j, :] + distance[j, :]

                else:

                    distance[j, :] = l_max * np.tile(a * R1, (1, ndim))
                    direction[j, 1] = np.cos(angle[j, 1])
                    for i in range(1, ndim - 1):
                        direction[j, i] = np.cos(angle[j, i]) * np.prod(np.sin(angle[j, i:ndim - 1]))
                    direction[j, ndim - 1] = np.prod(np.sin(angle[j, 1:ndim - 1]))
                    population[j, :] = population[j, :] + distance[j, :] * direction[j, :]

        outflag = np.where((population <= lowerbound) | (population >= upperbound), 1, 0)
        population = population - outflag * distance * direction

        for i in range(popsize):
            fvalue[i] = fitness(population[i, :],Xtrain,ytrain,Xval,yval)

        index = np.argmax(fvalue)
        fbestval = fvalue[index]
        best[atribu] = fbestval
        atribu += 1

        bestmember = population[index, :]

        #if ite / 10 == np.floor(ite):
        #    print("Best: ", fbestval)
        #    best[int(ite / 10)] = fbestval
        #    if fbestval == 0:
        #        best[(ite / 10):300] = 0
        #        break

    return fbestval, bestmember,best

"""# GSA (Gravitational Search Algorithm)"""

from math import exp
import numpy as np

def GSArun(population,fitness,lb,ub,iteration,Xtrain,ytrain,Xval,yval,G0=3):
  
  scores = []
  n = np.array(population).shape[0]
  dimension = np.array(population).shape[1]
  
  
  Pbest = population[np.array([fitness(x,Xtrain,ytrain,Xval,yval)
                                  for x in population]).argmax()]
  Gbest = Pbest
  velocity = np.array([[0 for k in range(dimension)] for i in range(n)])
  
  for t in range(iteration):
    
    csi = np.random.random((n, dimension))
    eps = np.random.random((1, n))[0]

    fitness2 = np.array([fitness(x,Xtrain,ytrain,Xval,yval) for x in population])

    m = np.array([(fitness(x,Xtrain,ytrain,Xval,yval) - max(fitness2)) /
               (min(fitness2) - max(fitness2)) for x in population])

    M = np.array([i / sum(m) for i in m])
    G = G0 / exp(0.01 * t)

    a = np.array([sum([eps[j] * G * M[j] *
                    (population[j] - population[i]) / (
        np.linalg.norm(population[i] - population[j]) + 0.001)
                    for j in range(n)]) for i in range(n)])

    velocity = csi * velocity + np.array([a[i] for i in range(n)])
    population += velocity
    population = np.clip(population, lb, ub)

    Pbest = population[np.array([fitness(x,Xtrain,ytrain,Xval,yval) 
                                 for x in population]).argmax()]

    fitPbest = fitness(Pbest,Xtrain,ytrain,Xval,yval)
    fitGbest = fitness(Gbest,Xtrain,ytrain,Xval,yval)

    if fitPbest > fitGbest:
      Gbest = Pbest
      scores.append(fitPbest)
    else:
      scores.append(fitGbest)
  
  return scores, Gbest

"""#GWO (Gray Wolf Optimizer)"""

import numpy as np

from SwarmPackagePy.intelligence import sw


class gwo(sw):

    def __init__(self, n, function, lb, ub, dimension, iteration,Xtrain,ytrain,Xval,yval,init = None):


        super(gwo, self).__init__()

        if init is None:
            self.__agents = np.random.uniform(lb, ub, (n, dimension))
        else:
            self.__agents = np.array(init)
            
        self._points(self.__agents)
        alpha, beta, delta = self.__get_abd(n, function,Xtrain,ytrain,Xval,yval)

        Gbest = alpha

        for t in range(iteration):

            a = 2 - 2 * t / iteration

            r1 = np.random.random((n, dimension))
            r2 = np.random.random((n, dimension))
            A1 = 2 * r1 * a - a
            C1 = 2 * r2

            r1 = np.random.random((n, dimension))
            r2 = np.random.random((n, dimension))
            A2 = 2 * r1 * a - a
            C2 = 2 * r2

            r1 = np.random.random((n, dimension))
            r2 = np.random.random((n, dimension))
            A3 = 2 * r1 * a - a
            C3 = 2 * r2

            Dalpha = abs(C1 * alpha - self.__agents)
            Dbeta = abs(C2 * beta - self.__agents)
            Ddelta = abs(C3 * delta - self.__agents)

            X1 = alpha - A1 * Dalpha
            X2 = beta - A2 * Dbeta
            X3 = delta - A3 * Ddelta
            self.__agents = (X1 + X2 + X3) / 3

            self.__agents = np.clip(self.__agents, lb, ub)
            self._points(self.__agents)

            alpha, beta, delta = self.__get_abd(n, function,Xtrain,ytrain,Xval,yval)
            if function(alpha,Xtrain,ytrain,Xval,yval) > function(Gbest,Xtrain,ytrain,Xval,yval):
                Gbest = alpha

        self._set_Gbest(Gbest)
        alpha, beta, delta = self.__get_abd(n, function,Xtrain,ytrain,Xval,yval)
        self.__leaders = list(alpha), list(beta), list(delta)

    def __get_abd(self, n, function,Xtrain,ytrain,Xval,yval):

        result = []
        fitness = [(function(self.__agents[i],Xtrain,ytrain,Xval,yval), i) for i in range(n)]
        fitness.sort(reverse=True)

        for i in range(3):
            result.append(self.__agents[fitness[i][1]])

        return result

    def get_leaders(self):

        return list(self.__leaders)

"""# GWO + GSO"""

def GWOGSOrun(population,lb,ub,iteration,Xtrain,ytrain,Xval,yval):
  
  popusplited = np.split(np.array(population),2) # DIVIDE A POPULAO
  popuGSO = popusplited[0]
  popuGWO = popusplited[1]
  sizepop = popuGWO.shape[0]
  dimpop = popuGWO.shape[1]
  
  for x in range(iteration): #GERAES
    
    x,y,best = GSO(fitnessGWOGSO,-1,1,1,popuGSO,X_trainK,y_trainK,X_valK,y_valK)   # REALIZA O PROCESSO DO GSO 1 VEZ E RETORNA MELHOR INDIVIDUO  
    popuGWO[random.randint(0,len(popuGWO)-1)] = y # ATUALIZA A POPULAO CM O MELHOR INDIVIDUO
    grey = gwo(sizepop,fitnessGWOGSO,-1,1,dimpop,1,X_trainK,y_trainK,X_valK,y_valK,init=popuGWO) # REALIZA O PROCESSO DO GWO 1 VEZ E RETORNA MELHOR INDIVIDUO
    popuGSO[random.randint(0,len(popuGSO)-1)] = grey.get_Gbest() #ATUALIZA A POPUALAO COM O MELHOR INDIVIDUO

"""#GSA+PSO"""

def GSAPSOrun(population,lb,ub,iteration,Xtrain,ytrain,Xval,yval):
  
  popusplited = np.split(np.array(population),2) # DIVIDE A POPULAO
  popuGSA = popusplited[0]
  popuPSO = popusplited[1]
  
  for x in range(iteration): # GERAES
    
    _, bestGSA = GSArun(popuGSA,fitnessGSAPSO,-1,1,1,X_trainK,y_trainK,X_valK,y_valK) # REALIZA O PROCESSO DO GSA 1 VEZ E RETORNA MELHOR INDIVIDUO
    popuPSO[random.randint(0,len(popuPSO)-1)] = bestGSA # ATUALIZA A POPULAO CM MELHOR INDIVIDUO
    _, bestPSO = PSOrun(popuPSO,fitnessGSAPSO,-1,1,1,X_trainK,y_trainK,X_valK,y_valK) # REALIZA O PROCESSO DO PSO 1 VEZ E RETORNA MELHOR INDIVIDUO
    popuGSA[random.randint(0,len(popuGSA)-1)] = bestPSO # ATUALIZA A POPULAO COM O MELHOR INDIVIDUO

"""# MAIN"""

#from keras import backend as K 
#K.clear_session()

ite = 35    # Quantidade de geraes dos algoritmos evolutivos 
iteKfold = 5 # Quantidade de iteraes que vai ser executado o cross validation de k = 10
scoresfinalMLP = [] # Array para salvar os score de validao da MLP
cont = 0 # Seed para o shuffle da base de dados
popu = 10 # Tamanho da populao
kvalue = 10

testGA = [] # Array para salvar as acurcias de teste do GA
testDE = [] # Array para salvar as acurcias de teste do DE
testEE = [] # Array para salvar as acurcias de teste do EE
testEEC = [] # Array para salvar as acurcias de teste do EEC
testPE = [] # Array para salvar as acurcias de teste do PE
testGADE = [] # Array para salvar as acurcias de teste do GADE
testPSO = [] # Array para salvar as acurcias de teste do PSO
testGSO = [] # Array para salvar as acurcias de teste do GSO
testMLP = [] # Array para salvar as acurcias de teste do MLP
testGWO = [] # Array para salvar as acurcias de teste do GWO
testGSA = [] # Array para salvar as acurcias de teste do GSA
testGWOGSO = []
testGSAPSO = []

timeGA = [] # Array para salvar os tempos de execuo dos Algoritmos
timeDE = [] # Array para salvar os tempos de execuo dos Algoritmos
timeEE = [] # Array para salvar os tempos de execuo dos Algoritmos
timeEEC = [] # Array para salvar os tempos de execuo dos Algoritmos
timePE = [] # Array para salvar os tempos de execuo dos Algoritmos
timeGADE = [] # Array para salvar os tempos de execuo dos Algoritmos
timePSO = [] # Array para salvar os tempos de execuo dos Algoritmos
timeGSO = [] # Array para salvar os tempos de execuo dos Algoritmos
timeMLP = [] # Array para salvar os tempos de execuo dos Algoritmos
timeGWO = [] # Array para salvar os tempos de execuo dos Algoritmos
timeGSA = [] # Array para salvar os tempos de execuo dos Algoritmos
timeGWOGSO = []
timeGSAPSO = []

k = KFold(kvalue,True,1) # Instancia da classe Kfold com k = 10

for x in range(iteKfold): # For da quantidade de vezes que ira ser executado o cross validation de k = 10
  
  for train_index,test_index in k.split(imagesnoclass): # For do Kfold com K = 10
    X_train, X_test = np.array(imagesnoclass)[train_index], np.array(imagesnoclass)[test_index] # Separando o conjunto de Treino separado a cima em treino e validao
    y_train, y_test = np.array(imagesclass)[train_index], np.array(imagesclass)[test_index] # Separando o conjunto de Treino separado a cima em treino e validao
       
    
    X_trainK, X_valK, y_trainK, y_valK = train_test_split(X_train, y_train, test_size=0.2)
    
    
    ############ CREATE POPU ######
    
    inicialpopulation = np.array(creatpopuMSRA(popu,306)) # Criando a populao inicial
    inicialstd = np.array(creatpopuSTD(popu,306)) # Criando a populao de desvio padres iniciais
    sizepop = inicialpopulation.shape[0] # Tamanho da populao
    dimpop = inicialpopulation.shape[1] # Dimenso da populao
    
    ############ CREATE POPU #########
    
    ######## MLP ############
    
    timeinicialMLP = time.time() # Instanciando o tempo de inicio da execuo do MLP
    modelMLP = Sequential() # Instanciando o modelo
    modelMLP.add(Dense(6, input_dim = 50, activation="relu")) # Instanciando o modelo
    modelMLP.add(Dense(1, activation="sigmoid")) # Instanciando o modelo
    modelMLP.compile( loss='binary_crossentropy', optimizer="adam",metrics=['accuracy']) # Instanciando o modelo
    
    modelMLP.fit(X_trainK, y_trainK, epochs=20, batch_size=256, verbose = False) # Treinando o modelo
    scoresfinalMLP.append(modelMLP.evaluate(X_valK,y_valK,verbose = False)[1]) # Avaliando o modelo com o conjunto de validao e guardando no array de validaes
  
    timefinalMLP = time.time() # pegando o tempo de termino
    timeMLP.append(timefinalMLP-timeinicialMLP) # Salvando o tempo de execuo
    
    ###### GA ########################
    
    scoresfinalGA, _, timetotalGA = GArun(inicialpopulation.copy(),ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o GA com os conjuntos de validao e treinamento e com o nmero
    timeGA.append(timetotalGA)                                                                  # de iteraes declaradas no inicio
      
    ####### DE ############################
    
    melhoresDE, scoresfinalDE,timetotalDE = de(fitnessDE , (-1,1) , inicialpopulation.copy(),ite,sizepop,X_trainK,y_trainK,X_valK,y_valK) # Rodando o DE com os conjuntos de validao e 
    timeDE.append(timetotalDE)                                                                                           # treinamento e com o nmero de iteraes declaradas no inicio
    
    ######### EE ###########################
    
    scoresfinalEE, _, timetotalEE = EErun(inicialpopulation.copy(),,inicialstd.copy(),,ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o EE com os conjuntos de validao e treinamento e com o nmero
    timeEE.append(timetotalEE)                                                                              # de iteraes declaradas no inicio
    
    ######## EEC ###########################
    
    scoresfinalEEC, _, timetotalEEC = EECrun(inicialpopulation.copy(),,inicialstd.copy(),,ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o EEC com os conjuntos de validao e treinamento e com o nmero
    timeEEC.append(timetotalEEC)                                                                               # de iteraes declaradas no inicio
    
    ######## PE ###############################
    
    scoresfinalPE,_,timetotalPE = PErun(inicialpopulation.copy(),,inicialstd.copy(),,ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o PE com os conjuntos de validao e treinamento e com o nmero
    timePE.append(timetotalPE)                                                                            # de iteraes declaradas no inicio
    
    #######GADE #############################
    
    scoresfinalGADE,_,timetotalGADE = GADErun(inicialpopulation.copy(),,ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o GADE com os conjuntos de validao e treinamento e com o nmero
    timeGADE.append(timetotalGADE)                                                                   # de iteraes declaradas no inicio
    
    ########## PSO ################################33

    timeinicialpso = time.time() 
    scoresfinalPSO,_ = PSOrun(inicialpopulation.copy(),,fitnessPSO,-1,1,ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o PSO com os conjuntos de validao e treinamento e com o nmero
                                                                                        # de iteraes declaradas no inicio
    timefinalpso = time.time()
    timePSO.append(timefinalpso - timeinicialpso)

    ################### GSO ###############################

    timeinicialgso = time.time()
    x,y,scoresGSO = GSO(fitnessGSO,-1,1,ite,inicialpopulation.copy(),,X_trainK,y_trainK,X_valK,y_valK) # Rodando o GSO com os conjuntos de validao e treinamento e com o nmero
                                                                                          # de iteraes declaradas no inicio
    timefinalgso = time.time()
    scoresfinalGSO = np.array(scoresGSO)
    timeGSO.append(timefinalgso - timeinicialgso) 
    
    ################ GWO ############################
    
    timeinicialgwo = time.time()
    grey = gwo(sizepop,fitnessGWO,-1,1,dimpop,ite,X_trainK,y_trainK,X_valK,y_valK,init=inicialpopulation.copy(),)# Rodando o GWO com os conjuntos de validao e treinamento e com o nmero
                                                                                                          # de iteraes declaradas no inicio
    timefinalgwo = time.time()
    timeGWO.append(timefinalgwo - timeinicialgwo)
    
    
    ################# GSA ############################
    
    timeinicialgsa = time.time()
    scoresfinalGSA,_ = GSArun(inicialpopulation.copy(),,fitnessGSA,-1,1,ite,X_trainK,y_trainK,X_valK,y_valK) # Rodando o GSA com os conjuntos de validao e treinamento e com o nmero
                                                                                        # de iteraes declaradas no inicio
    timefinalgsa = time.time()
    timeGSA.append(timefinalgsa - timeinicialgsa)
    
    ############## GWO + GSO #############
    
    timeinicialgwogso = time.time()
    GWOGSOrun(inicialpopulation.copy(),,-1,1,ite,X_trainK,y_trainK,X_valK,y_valK)
    timefinalgwogso = time.time()
    timeGWOGSO.append(timefinalgwogso-timeinicialgwogso)
    
    ############# GSA + PSO ################
    
    timeinicialgsapso = time.time()
    GSAPSOrun(inicialpopulation.copy(),,-1,1,ite,X_trainK,y_trainK,X_valK,y_valK)
    timefinalgsapso = time.time()
    timeGSAPSO.append(timefinalgsapso - timeinicialgsapso)
    
    
    
    modelGA = loadmodelGA() # Carregando o melhor modelo gerado pelo GA para teste
    modelDE = loadmodelDE() # Carregando o melhor modelo gerado pelo DE para teste
    modelEE = loadmodelEE() # Carregando o melhor modelo gerado pelo EE para teste
    modelEEC = loadmodelEEC() # Carregando o melhor modelo gerado pelo EEC para teste
    modelPE = loadmodelPE() # Carregando o melhor modelo gerado pelo PE para teste
    modelGADE = loadmodelGADE() # Carregando o melhor modelo gerado pelo GADE para teste
    modelPSO = loadmodelPSO() # Carregando o melhor modelo gerado pelo PSO para teste
    modelGSO = loadmodelGSO() # Carregando o melhor modelo gerado pelo GSO para teste
    modelGWO = loadmodelGWO() # Carregando o melhor modelo gerado pelo GWO para teste
    modelGSA = loadmodelGSA() # Carregando o melhor modelo gerado pelo GSA para teste
    modelGWOGSO = loadmodelGWOGSO()
    modelGSAPSO = loadmodelGSAPSO()
       
    testGA.append(modelGA.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o melhor modelo do GA com o conjunto de teste
    testDE.append(modelDE.evaluate(X_test,y_test,  verbose = False)[1]) # Avaliando o melhor modelo do DE com o conjunto de teste
    testEE.append(modelEE.evaluate(X_test,y_test,  verbose = False)[1]) # Avaliando o melhor modelo do EE com o conjunto de teste
    testEEC.append(modelEEC.evaluate(X_test,y_test,  verbose = False)[1]) # Avaliando o melhor modelo do EEC com o conjunto de teste
    testPE.append(modelPE.evaluate(X_test,y_test,  verbose = False)[1]) # Avaliando o melhor modelo do PE com o conjunto de teste
    testGADE.append(modelGADE.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o melhor modelo do GADE com o conjunto de teste
    testMLP.append(modelMLP.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o modelo do MLP com o conjunto de teste
    testPSO.append(modelPSO.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o melhor modelo do PSO com o conjunto de teste
    testGSO.append(modelGSO.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o melhor modelo do GSO com o conjunto de teste
    testGWO.append(modelGWO.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o melhor modelo do GWO com o conjunto de teste
    testGSA.append(modelGSA.evaluate(X_test,y_test, verbose = False)[1]) # Avaliando o melhor modelo do GSA com o conjunto de teste
    testGWOGSO.append(modelGWOGSO.evaluate(X_test,y_test, verbose = False)[1])
    testGSAPSO.append(modelGSAPSO.evaluate(X_test,y_test, verbose = False)[1])
    
    arrayfitnessGA = [] # Aqui eu zero os vetores que eu utilizo
    arrayfitnessDE = [] # para saber qual  o melhor modelo gerado por aquela
    arrayfitnessEE = [] # gerao, de forma em que possa ser pego na proxima 
    arrayfitnessEEC = [] # iterao dentro do kfold o novo melhor modelo gerado
    arrayfitnessPE = [] # e no talvez o antigo melhor modelo
    arrayfitnessGADE = []
    arrayfitnessPSO = []
    arrayfitnessGSO = []
    arrayfitnessGSA = []
    arrayfitnessGWO = []
    arrayfitnessGWOGSO = []
    arrayfitnessGSAPSO = []
    
    print("end")
  
  imagesnoclass, imagesclass = shuffle(imagesnoclass, imagesclass, random_state=cont) # Depois que termina as 10 iteraes de um Kfold dou shuffle
  cont += 1 # Valor da seed do shufle sendo somado +1
  #K.clear_session()
  
datacsv = []

for ite2 in range(iteKfold*kvalue):
    aux = []
    aux.append(testGA[ite2])
    aux.append(testDE[ite2])
    aux.append(testEE[ite2])
    aux.append(testEEC[ite2])
    aux.append(testPE[ite2])
    aux.append(testGADE[ite2])
    aux.append(testMLP[ite2])
    aux.append(testPSO[ite2])
    aux.append(testGSO[ite2])
    aux.append(testGWO[ite2])
    aux.append(testGSA[ite2])
    aux.append(testGWOGSO[ite2])
    aux.append(testGSAPSO[ite2])

    datacsv.append(aux)


stat, p = friedmanchisquare(testGA,testDE,testEE,testEEC,testPE,testGADE,testMLP,testPSO,testGSO,testGWO,testGSA,testGWOGSO,testGSAPSO)

datacsv = pd.DataFrame(datacsv, columns=['GA','DE','EE','EEC','PE','GA+DE','MLP','PSO','GSO','GWO','GSA','GWO+GSO','GSA+PSO'])

dataplot = datacsv.boxplot(column=['GA','DE','EE','EEC','PE','GA+DE','MLP','PSO','GSO','GWO','GSA','GWO+GSO','GSA+PSO'],figsize=(12,8))
plt.xlabel('Algorithms')
plt.ylabel('Acuracy score')
plt.title('P-value:'+ str(p))

print(datacsv)

print("ACURA BEST")
print(testGA[np.argmax(testGA)])
print(testDE[np.argmax(testDE)])
print(testEE[np.argmax(testEE)])
print(testEEC[np.argmax(testEEC)])
print(testPE[np.argmax(testPE)])
print(testGADE[np.argmax(testGADE)])
print(testMLP[np.argmax(testMLP)])
print(testPSO[np.argmax(testPSO)])
print(testGSO[np.argmax(testGSO)])
print(testGWO[np.argmax(testGWO)])
print(testGSA[np.argmax(testGSA)])
print(testGWOGSO[np.argmax(testGWOGSO)])
print(testGSAPSO[np.argmax(testGSAPSO)])

print()
print("MEDIA TEST")
print(np.mean(testGA))
print(np.mean(testDE))
print(np.mean(testEE))
print(np.mean(testEEC))
print(np.mean(testPE))
print(np.mean(testGADE))
print(np.mean(testMLP))
print(np.mean(testPSO))
print(np.mean(testGSO))
print(np.mean(testGWO))
print(np.mean(testGSA))
print(np.mean(testGWOGSO))
print(np.mean(testGSAPSO))

print("MEDIANA TEST")
print(np.median(testGA))
print(np.median(testDE))
print(np.median(testEE))
print(np.median(testEEC))
print(np.median(testPE))
print(np.median(testGADE))
print(np.median(testMLP))
print(np.median(testPSO))
print(np.median(testGSO))
print(np.median(testGWO))
print(np.median(testGSA))
print(np.median(testGWOGSO))
print(np.median(testGSAPSO))

print("STD TEST")
print(np.std(testGA))
print(np.std(testDE))
print(np.std(testEE))
print(np.std(testEEC))
print(np.std(testPE))
print(np.std(testGADE))
print(np.std(testMLP))
print(np.std(testPSO))
print(np.std(testGSO))
print(np.std(testGWO))
print(np.std(testGSA))
print(np.std(testGWOGSO))
print(np.std(testGSAPSO))

print("TIMES MDIO")
print(np.mean(timeGA))
print(np.mean(timeDE))
print(np.mean(timeEE))
print(np.mean(timeEEC))
print(np.mean(timePE))
print(np.mean(timeGADE))
print(np.mean(timeMLP))
print(np.mean(timePSO))
print(np.mean(timeGSO))
print(np.mean(timeGWO))
print(np.mean(timeGSA))
print(np.mean(timeGWOGSO))
print(np.mean(timeGSAPSO))

print("TIMES TOTAL")
print(np.sum(timeGA))
print(np.sum(timeDE))
print(np.sum(timeEE))
print(np.sum(timeEEC))
print(np.sum(timePE))
print(np.sum(timeGADE))
print(np.sum(timeMLP))
print(np.sum(timePSO))
print(np.sum(timeGSO))
print(np.sum(timeGWO))
print(np.sum(timeGSA))
print(np.sum(timeGWOGSO))
print(np.sum(timeGSAPSO))

print(datacsv.mean(axis = 0))
print(datacsv.std())

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0, len(testGA)), testGA, label="GA" )
plt.plot(np.arange(0, len(testDE)), testDE, label="DE")
plt.plot(np.arange(0, len(testEE)), testEE, label="EE" )
plt.plot(np.arange(0, len(testEEC)), testEEC, label="EEC")
plt.plot(np.arange(0, len(testPE)), testPE, label="PE" )
plt.plot(np.arange(0, len(testGADE)), testGADE, label="GADE")
plt.plot(np.arange(0, len(testPSO)), testPSO, label="PSO" )
plt.plot(np.arange(0, len(testGSO)), testGSO, label="GSO")
plt.plot(np.arange(0, len(testGWO)), testGWO, label = 'GWO')
plt.plot(np.arange(0, len(testGSA)), testGSA, label = 'GSA')
plt.title("Fitness growing")
plt.xlabel("Iteration")
plt.ylabel("Fitness value")
plt.legend()
plt.show()

"""# Kfold part DONT USE"""

k = KFold(n_splits=10)


################## INICIO KFOLD MLP SOZINHA #######################

scoresfinalMLP = []
modelMLP = Sequential()
modelMLP.add(Dense(6, input_dim = 50, activation="relu"))
modelMLP.add(Dense(1, activation="sigmoid"))    
modelMLP.compile( loss='binary_crossentropy', optimizer="adam", 
              metrics=['accuracy'])


#model3 = Sequential()
#model3.add(Dense(6, input_dim = 50, activation="relu"))
#model3.add(Dense(1, activation="sigmoid"))    
#model3.compile( loss='binary_crossentropy', optimizer="adam", 
#              metrics=['accuracy'])
#model3.load_weights("modelDE.h5")

#model3.fit(df_train_nolabels, df_train_labels, epochs=20, batch_size=256, verbose = False)
#retorno = model3.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
#retorno2 = model3.evaluate(df_test_nolabels,df_test_labels,verbose = False)
#print("look")
#print(retorno[1])
#print(retorno2[1])
#print()


timeinicialMLP = time.time()
for x in range(10):
  print("tam")
  for train_index, test_index in k.split(mlpdataX): 
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelMLP.fit(X_train, y_train, epochs=20, batch_size=256, verbose = False)
    retorno = modelMLP.evaluate(X_test,y_test, verbose = False)
    aux.append(retorno[1])    
      
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)

  scoresfinalMLP.append(np.mean(aux))
timefinalMLP = time.time()
timetotalMLP = timefinalMLP - timeinicialMLP

    
    
################ FIM MLP SOZINHA ################################

############## KFOLD GA ##############################

kfoldscoresGA = []
modelGA = loadmodelGA()


for xGA in range(10):
  for train_index,test_index in k.split(mlpdataX):
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelGA.fit(X_train,y_train,epochs=20,batch_size = 256,verbose = False)
    retorno = modelGA.evaluate(X_test,y_test,verbose = False)
    aux.append(retorno[1])
    
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)
    
  kfoldscoresGA.append(np.mean(aux))
  
    

############### FIM KFOLD GA ##################################

###################### KFOLD DE ##############################

kfoldscoresDE = []
modelDE = loadmodelDE()


for xDE in range(10):
  for train_index,test_index in k.split(mlpdataX):
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelDE.fit(X_train,y_train,epochs=20,batch_size = 256,verbose = False)
    retorno = modelDE.evaluate(X_test,y_test,verbose = False)
    aux.append(retorno[1])
    
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)

  kfoldscoresDE.append(np.mean(aux))
  
                                
                               
################# FIM KFOLD DE ################################

################### KFOLD EE #################################
                                
kfoldscoresEE = [] 
modelEE = loadmodelEE()                              

for xEE in range(10):
  for train_index,test_index in k.split(mlpdataX):
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelEE.fit(X_train,y_train,epochs=20,batch_size = 256,verbose = False)
    retorno = modelEE.evaluate(X_test,y_test,verbose = False)
    aux.append(retorno[1])
    
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)
  
  kfoldscoresEE.append(np.mean(aux))                                

################### FIM KFOLD EE ############################
                                
###################  KFOLD EEC ############################
kfoldscoresEEC = []
modelEEC = loadmodelEEC()
                                
for xEEC in range(10):
  for train_index,test_index in k.split(mlpdataX):
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelEEC.fit(X_train,y_train,epochs=20,batch_size = 256,verbose = False)
    retorno = modelEEC.evaluate(X_test,y_test,verbose = False)
    aux.append(retorno[1])
    
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)
  
  kfoldscoresEEC.append(np.mean(aux))    
                                
################### FIM KFOLD EEC ############################                                
                                
#################### KFOLD PE ####################
                                
kfoldscoresPE = []
modelPE = loadmodelPE()
                                
for xPE in range(10):
  for train_index,test_index in k.split(mlpdataX):
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelPE.fit(X_train,y_train,epochs=20,batch_size = 256,verbose = False)
    retorno = modelPE.evaluate(X_test,y_test,verbose = False)
    aux.append(retorno[1])
    
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)
  
  kfoldscoresPE.append(np.mean(aux))   
                                
##################### FIM KFOLD PE ########################
######################## KFOLD GA DE####################                               
kfoldscoresGADE = []
modelGADE = loadmodelGADE()

for xPE in range(10):
  for train_index,test_index in k.split(mlpdataX):
    aux = []
    X_train, X_test = mlpdataX[train_index], mlpdataX[test_index]
    y_train, y_test = mlpdataY[train_index], mlpdataY[test_index]
    
    modelGADE.fit(X_train,y_train,epochs=20,batch_size = 256,verbose = False)
    retorno = modelGADE.evaluate(X_test,y_test,verbose = False)
    aux.append(retorno[1])
    
    mlpdataX,mlpdataY = shuffle(mlpdataX, mlpdataY, random_state=0)
  
  kfoldscoresGADE.append(np.mean(aux))

"""# OLD FITNESS NO KFOLD ---DONT USE--"""

graphGA = []
graphDE = []
graphEE = []
graphEEC = []
graphPE = []
graphGADE = []
graphPSO = []
graphGSO = []



def fitnessGA(chromossome):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessGA) == 0:
    graphGA.append(retorno[1])
    model_json = model.to_json()
    with open("modelGA.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGA.h5")
  

  atual = retorno[1]
  
  if len(arrayfitnessGA) > 1:
    if atual >= arrayfitnessGA[np.argmax(arrayfitnessGA)]:
      graphGA.append(atual)
    else:
      graphGA.append(arrayfitnessGA[np.argmax(arrayfitnessGA)])
  
  if len(arrayfitnessGA) > 1:
    if atual > arrayfitnessGA[np.argmax(arrayfitnessGA)]:
      model_json = model.to_json()
      with open("modelGA.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGA.h5")
  
  arrayfitnessGA.append(retorno[1])
  return retorno[1]


def fitnessDE(chromossome):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessDE) == 0:
    graphDE.append(retorno[1])
    model_json = model.to_json()
    with open("modelDE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelDE.h5")
  
  atual = retorno[1]
  
  if len(arrayfitnessDE) > 1:
    if atual >= arrayfitnessDE[np.argmax(arrayfitnessDE)]:
      graphDE.append(atual)
    else:
      graphDE.append(arrayfitnessDE[np.argmax(arrayfitnessDE)])  
  
  if len(arrayfitnessDE) > 1:
    if atual > arrayfitnessDE[np.argmax(arrayfitnessDE)]:
      model_json = model.to_json()
      with open("modelDE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelDE.h5")
      
  arrayfitnessDE.append(retorno[1])
  return retorno[1]

def fitnessEE(chromossome):
  
  
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessEE) == 0:
    graphEE.append(retorno[1])
    model_json = model.to_json()
    with open("modelEE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelEE.h5")
  
  atual = retorno[1]
  
  if len(arrayfitnessEE) > 1:
    if atual >= arrayfitnessEE[np.argmax(arrayfitnessEE)]:
      graphEE.append(atual)
    else:
      graphEE.append(arrayfitnessEE[np.argmax(arrayfitnessEE)])
      
  if len(arrayfitnessEE) > 1:
    if atual > arrayfitnessEE[np.argmax(arrayfitnessEE)]:
      model_json = model.to_json()
      with open("modelEE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelEE.h5")
      
  arrayfitnessEE.append(retorno[1])
  return retorno[1]

def fitnessEEC(chromossome):
  
  
  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessEEC) == 0:
    graphEEC.append(retorno[1])
    model_json = model.to_json()
    with open("modelEEC.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelEEC.h5")
  
  atual = retorno[1]
  
  if len(arrayfitnessEEC) > 1:
    if atual >= arrayfitnessEEC[np.argmax(arrayfitnessEEC)]:
      graphEEC.append(atual)
    else:
      graphEEC.append(arrayfitnessEEC[np.argmax(arrayfitnessEEC)])
    
  if len(arrayfitnessEEC) > 1:
    if atual > arrayfitnessEEC[np.argmax(arrayfitnessEEC)]:
      model_json = model.to_json()
      with open("modelEEC.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelEEC.h5")
      
  arrayfitnessEEC.append(retorno[1])  
  return retorno[1]

def fitnessPE(chromossome):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  
  if len(arrayfitnessPE) == 0:
    graphPE.append(retorno[1])
    model_json = model.to_json()
    with open("modelPE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelPE.h5")
  
  atual = retorno[1]
  
  if len(arrayfitnessPE) > 1:
    if atual >= arrayfitnessPE[np.argmax(arrayfitnessPE)]:
      graphPE.append(atual)
    else:
      graphPE.append(arrayfitnessPE[np.argmax(arrayfitnessPE)])  
  
  if len(arrayfitnessPE) > 1:
    if atual > arrayfitnessPE[np.argmax(arrayfitnessPE)]:
      model_json = model.to_json()
      with open("modelPE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelPE.h5")
      
  arrayfitnessPE.append(retorno[1])
  return retorno[1]



def fitnessGADE(chromossome):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessGADE) == 0:
    graphGADE.append(retorno[1])
    model_json = model.to_json()
    with open("modelGADE.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGADE.h5")

  atual = retorno[1]
  
  if len(arrayfitnessGADE) > 1:
    if atual >= arrayfitnessGADE[np.argmax(arrayfitnessGADE)]:
      graphGADE.append(atual)
    else:
      graphGADE.append(arrayfitnessGADE[np.argmax(arrayfitnessGADE)])
  
  if len(arrayfitnessGADE) > 1:
    if atual > arrayfitnessGADE[np.argmax(arrayfitnessGADE)]:
      model_json = model.to_json()
      with open("modelGADE.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGADE.h5")
  
  arrayfitnessGADE.append(retorno[1])
  return retorno[1]


def fitnessPSO(chromossome):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessPSO) == 0:
    graphPSO.append(retorno[1])
    model_json = model.to_json()
    with open("modelPSO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelPSO.h5")

  atual = retorno[1]
  
  if len(arrayfitnessPSO) > 1:
    if atual >= arrayfitnessPSO[np.argmax(arrayfitnessPSO)]:
      graphPSO.append(atual)
    else:
      graphPSO.append(arrayfitnessPSO[np.argmax(arrayfitnessPSO)])
  
  if len(arrayfitnessPSO) > 1:
    if atual > arrayfitnessPSO[np.argmax(arrayfitnessPSO)]:
      model_json = model.to_json()
      with open("modelPSO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelPSO.h5")
  
  arrayfitnessPSO.append(retorno[1])
  return retorno[1]


def fitnessGSO(chromossome):
  

  w1 = np.split(np.array(chromossome[0:len(chromossome)-6]), 50)
  w2 = np.reshape(chromossome[len(chromossome)-7:len(chromossome)-1], (6, 1))
  
  model.get_layer('dense1').set_weights((np.array(w1), np.zeros(6)))
  model.get_layer('dense2').set_weights((np.array(w2), np.zeros(1)))

  hist = model.fit(df_train_nolabels, df_train_labels, epochs=50, batch_size=256, verbose = False)
  retorno = model.evaluate(df_validation_nolabels,df_validation_labels, verbose = False)
  
  if len(arrayfitnessGSO) == 0:
    graphGSO.append(retorno[1])
    model_json = model.to_json()
    with open("modelGSO.json", "w") as json_file:
      json_file.write(model_json)
    model.save_weights("modelGSO.h5")

  atual = retorno[1]
  
  if len(arrayfitnessGSO) > 1:
    if atual >= arrayfitnessGSO[np.argmax(arrayfitnessGSO)]:
      graphGSO.append(atual)
    else:
      graphGSO.append(arrayfitnessGSO[np.argmax(arrayfitnessGSO)])
  
  if len(arrayfitnessGSO) > 1:
    if atual > arrayfitnessGSO[np.argmax(arrayfitnessGSO)]:
      model_json = model.to_json()
      with open("modelGSO.json", "w") as json_file:
        json_file.write(model_json)
      model.save_weights("modelGSO.h5")
  
  arrayfitnessGSO.append(retorno[1])
  return retorno[1]



from SwarmPackagePy.intelligence import sw


class gsa(sw):

    def __init__(self, n, function, lb, ub, dimension, iteration,Xtrain,ytrain,Xval,yval, init=None, G0=3):

        super(gsa, self).__init__()

        if init is None:
            self.__agents = np.random.uniform(lb, ub, (n, dimension))
        else:
            self.__agents = np.array(init)
        
        self._points(self.__agents)

        Pbest = self.__agents[np.array([function(x,Xtrain,ytrain,Xval,yval)
                                        for x in self.__agents]).argmax()]
        Gbest = Pbest

        velocity = np.array([[0 for k in range(dimension)] for i in range(n)])

        for t in range(iteration):

            csi = np.random.random((n, dimension))
            eps = np.random.random((1, n))[0]

            fitness = np.array([function(x,Xtrain,ytrain,Xval,yval) for x in self.__agents])

            m = np.array([(function(x,Xtrain,ytrain,Xval,yval) - max(fitness)) /
                       (min(fitness) - max(fitness)) for x in self.__agents])
            M = np.array([i / sum(m) for i in m])

            G = G0 / exp(0.01 * t)
            a = np.array([sum([eps[j] * G * M[j] *
                            (self.__agents[j] - self.__agents[i]) / (
                np.linalg.norm(self.__agents[i] - self.__agents[j]) + 0.001)
                            for j in range(n)]) for i in range(n)])

            velocity = csi * velocity + np.array([a[i] for i in range(n)])
            self.__agents += velocity
            self.__agents = np.clip(self.__agents, lb, ub)
            self._points(self.__agents)

            Pbest = self.__agents[
                np.array([function(x,Xtrain,ytrain,Xval,yval) for x in self.__agents]).argmax()]
            if function(Pbest,Xtrain,ytrain,Xval,yval) > function(Gbest,Xtrain,ytrain,Xval,yval):
                Gbest = Pbest

        self._set_Gbest(Gbest)
        
        
from SwarmPackagePy.intelligence import sw

class pso(sw):

    def __init__(self, n, function, lb, ub, dimension, iteration,Xtrain,ytrain,Xval,yval, init=None, w=0.5, c1=1,
                 c2=1):

        super(pso, self).__init__()
        self.scores = []

        if init is None:
            self.__agents = np.random.uniform(lb, ub, (n, dimension))
        else:
            self.__agents = np.array(init)

        velocity = np.zeros((n, dimension))
        self._points(self.__agents)
        

        Pbest = self.__agents[np.array([function(x,Xtrain,ytrain,Xval,yval)
                                        for x in self.__agents]).argmax()]
        Gbest = Pbest
        

        for t in range(iteration):

            r1 = np.random.random((n, dimension))
            r2 = np.random.random((n, dimension))
            velocity = w * velocity + c1 * r1 * (
                Pbest - self.__agents) + c2 * r2 * (
                Gbest - self.__agents)
            self.__agents += velocity
            self.__agents = np.clip(self.__agents, lb, ub)
            self._points(self.__agents)

            Pbest = self.__agents[
                np.array([function(x,Xtrain,ytrain,Xval,yval) for x in self.__agents]).argmax()]
            
            self.scores.append(function(Pbest,Xtrain,ytrain,Xval,yval))
            if function(Pbest,Xtrain,ytrain,Xval,yval) > function(Gbest,Xtrain,ytrain,Xval,yval):
                Gbest = Pbest


        self._set_Gbest(Gbest)
               
    
    def get_Score(self):     
      return self.scores